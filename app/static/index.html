<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Card Inventory Scanner</title>
  <style>
    body { 
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
      margin: 0; 
      padding: 0; 
      background: #0b0c10; 
      color: #eaf0f6; 
      min-height: 100vh;
    }
    
    header { 
      padding: 12px 16px; 
      text-align: center; 
      background: #1f2833; 
      position: sticky; 
      top: 0; 
      z-index: 1; 
    }
    
    header h2 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    main { 
      padding: 12px; 
      max-width: 100%;
      margin: 0 auto;
    }
    
    @media (min-width: 768px) {
      main {
        padding: 16px;
        max-width: 600px;
      }
      
      header h2 {
        font-size: 2rem;
      }
    }
    
    .card { 
      background: #14171a; 
      border-radius: 12px; 
      padding: 16px; 
      box-shadow: 0 2px 12px rgba(0,0,0,.35); 
      margin-bottom: 16px; 
    }
    
    .grid { 
      display: grid; 
      gap: 12px; 
    }
    
    video { 
      width: 100%; 
      max-height: 40vh; 
      background: #000; 
      border-radius: 10px; 
      border: 2px solid #333; 
    }
    
    @media (max-width: 767px) {
      video {
        max-height: 35vh;
      }
    }
    video.testing { border: 2px solid #45a29e; background: #1a1a1a; box-shadow: 0 0 10px rgba(69, 162, 158, 0.5); }
    video.error { border: 2px solid #e74c3c; background: #2a1a1a; box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
    video:not([srcObject]) { background: #1a1a1a; border: 2px dashed #666; }
    button { 
      font-size: 16px; 
      padding: 12px 16px; 
      border: none; 
      border-radius: 10px; 
      background: #45a29e; 
      color: #0b0c10; 
      font-weight: 700; 
      cursor: pointer; 
      min-height: 44px; /* iOS touch target minimum */
      touch-action: manipulation;
    }
    
    button.secondary { background: #c5c6c7; color: #0b0c10; }
    button.danger { background: #e74c3c; color: white; }
    button.success { background: #27ae60; color: white; }
    
    /* Mobile button grid */
    .button-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 480px) {
      .button-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (min-width: 768px) {
      .button-grid {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
      }
    }
    input[type="text"], input[type="number"], textarea, select { 
      width: 100%; 
      padding: 12px; 
      font-size: 16px; 
      border-radius: 8px; 
      border: 1px solid #334; 
      background: #0f1113; 
      color: #eaf0f6; 
      margin-bottom: 12px; 
      box-sizing: border-box;
      -webkit-appearance: none;
      border-radius: 8px;
    }
    
    textarea { 
      resize: vertical; 
      min-height: 80px; 
    }
    
    select {
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .row { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
    }
    
    .toast { 
      margin-top: 8px; 
      padding: 12px; 
      border-radius: 8px; 
      background: #173f2a; 
      color: #b7ffd8; 
      display: none; 
      font-size: 14px;
    }
    .error { background: #3f1717; color: #ffb7b7; }
    .warning { background: #3f2f17; color: #ffd7b7; }
    .muted { color: #9aa5b1; font-size: 14px; }
    .small { font-size: 12px; }
    a { color: #66fcf1; }
    .form-group { margin-bottom: 12px; }
    .form-group label { display: block; margin-bottom: 4px; font-weight: 600; }
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; }
    .modal-content { 
      position: relative; 
      background: #14171a; 
      margin: 10px; 
      padding: 20px; 
      border-radius: 12px; 
      max-width: 500px; 
      max-height: 90vh; 
      overflow-y: auto; 
    }
    
    @media (min-width: 768px) {
      .modal-content {
        margin: 20px auto;
      }
    }
    
    .close { 
      position: absolute; 
      top: 10px; 
      right: 15px; 
      font-size: 24px; 
      cursor: pointer; 
      color: #9aa5b1; 
      padding: 8px;
      min-height: 44px;
      min-width: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .close:hover { color: #eaf0f6; }
    .hidden { display: none; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .flex-1 { flex: 1; }
    .gap-2 { gap: 8px; }
    .mb-2 { margin-bottom: 8px; }
    .mb-4 { margin-bottom: 16px; }
  </style>
  <script src="https://unpkg.com/@zxing/library@0.20.0"></script>
  <script>
    // Fallback ZXing library if the main one fails to load
    if (typeof ZXing === 'undefined') {
      console.log('Primary ZXing library failed to load, trying fallback...');
      const script = document.createElement('script');
      script.src = 'https://unpkg.com/@zxing/library@0.19.6';
      script.onload = () => console.log('Fallback ZXing library loaded successfully');
      script.onerror = () => console.error('All ZXing library versions failed to load');
      document.head.appendChild(script);
    }
  </script>
</head>
<body>
  <header>
    <h2>Card Inventory</h2>
  </header>
  <main class="grid">
    <section class="card">
      <div class="grid">
        <video id="video" playsinline autoplay muted></video>
        <div class="button-grid">
          <button id="startBtn">Start Scanning</button>
          <button id="stopBtn" class="secondary">Stop Scanner</button>
          <button id="stopVideoBtn" class="secondary">Stop Video</button>
          <button id="restartVideoBtn" class="secondary">Restart Video</button>
          <button id="recoverVideoBtn" class="secondary">Recover Video</button>
          <button id="permissionBtn" class="secondary">Request Camera Permission</button>
          <button id="testVideoBtn" class="secondary">Test Video</button>
          <button id="testBarcodeBtn" class="secondary">Test Barcode</button>
        <button id="generateTestBarcodeBtn" class="secondary">Generate Test Barcode</button>
          <button id="captureBtn" class="secondary">Capture & Decode</button>
          <button id="exportFramesBtn" class="secondary">Export Failed Frames</button>
          <button id="exportStatsBtn" class="secondary">Export All Stats</button>
          <button id="debugToggleBtn" class="secondary">Debug Info</button>
        </div>
        <div class="muted small">
          <strong>iPhone Camera Issues?</strong><br>
          • Use Safari (not Chrome)<br>
          • Go to Settings → Privacy → Camera → Safari<br>
          • Try adding to Home Screen<br>
          • Use manual entry below as backup
        </div>
        <div id="debugInfo" class="muted small" style="display: none;">
          <strong>Debug Info:</strong><br>
          <span id="cameraStatus">Camera: Unknown</span><br>
          <span id="videoStatus">Video: Unknown</span><br>
          <span id="scannerStatus">Scanner: Unknown</span><br>
          <span id="frameStats">Frame Stats: Unknown</span><br>
          <span id="qualityStats">Quality: Unknown</span>
        </div>
        <div id="toast" class="toast"></div>
      </div>
    </section>

    <section class="card">
      <h3>Manual Entry</h3>
      <div class="form-group">
        <input type="text" id="manualBarcode" placeholder="Enter barcode (UPC/EAN)" inputmode="numeric" />
      </div>
      <div class="form-group">
        <button id="manualBtn">Add</button>
      </div>
    </section>

    <section class="card">
      <h3>Tips</h3>
      <ul>
        <li>Add this page to Home Screen in Safari.</li>
        <li>Good lighting improves scan reliability.</li>
        <li>Use landscape if autofocus struggles.</li>
        <li>New items will prompt for additional details.</li>
      </ul>
      <div class="small muted">API: <a href="/docs">Swagger</a></div>
    </section>
  </main>

  <!-- New Item Modal -->
  <div id="newItemModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeNewItemModal()">&times;</span>
      <h3>Add New Item</h3>
      <p class="muted">Barcode: <span id="newItemBarcode"></span></p>
      
      <form id="newItemForm">
        <div class="form-group">
          <label for="itemName">Name</label>
          <input type="text" id="itemName" placeholder="Card name">
        </div>
        
        <div class="form-group">
          <label for="itemGame">Game</label>
          <select id="itemGame">
            <option value="">Select game...</option>
            <option value="Pokémon">Pokémon</option>
            <option value="Magic: The Gathering">Magic: The Gathering</option>
            <option value="Yu-Gi-Oh!">Yu-Gi-Oh!</option>
            <option value="NFL">NFL</option>
            <option value="NBA">NBA</option>
            <option value="MLB">MLB</option>
            <option value="WNBA">WNBA</option>
            <option value="Hockey">Hockey</option>
            <option value="College">College</option>
            <option value="MMA">MMA</option>
            <option value="Soccer">Soccer</option>
            <option value="Other">Other</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="itemSet">Set</label>
          <input type="text" id="itemSet" placeholder="Set name">
        </div>
        <div class="form-group">
          <label for="itemNumber">Number</label>
          <input type="text" id="itemNumber" placeholder="Card number">
        </div>
        
        <div class="form-group">
          <label for="itemQuantity">Quantity</label>
          <input type="number" id="itemQuantity" value="1" min="1">
        </div>
        
        <div class="form-group">
          <label for="itemPrice">Price ($)</label>
          <input type="number" id="itemPrice" step="0.01" min="0" placeholder="0.00">
        </div>
        
        <div class="form-group">
          <label for="itemLocation">Location</label>
          <input type="text" id="itemLocation" placeholder="Binder, box, etc.">
        </div>
        
        <div class="form-group">
          <label for="itemDescription">Description</label>
          <textarea id="itemDescription" placeholder="Additional details about the card..."></textarea>
        </div>
        
        <div class="form-group">
          <label for="itemNotes">Notes</label>
          <textarea id="itemNotes" placeholder="Personal notes..."></textarea>
        </div>
        
        <div class="form-group">
          <button type="submit" class="success">Add Item</button>
        </div>
        <div class="form-group">
          <button type="button" class="secondary" onclick="closeNewItemModal()">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stopVideoBtn = document.getElementById('stopVideoBtn');
    const restartVideoBtn = document.getElementById('restartVideoBtn');
    const recoverVideoBtn = document.getElementById('recoverVideoBtn');
    const permissionBtn = document.getElementById('permissionBtn');
    const testVideoBtn = document.getElementById('testVideoBtn');
    const testBarcodeBtn = document.getElementById('testBarcodeBtn');
    const generateTestBarcodeBtn = document.getElementById('generateTestBarcodeBtn');
    const captureBtn = document.getElementById('captureBtn');
    const exportFramesBtn = document.getElementById('exportFramesBtn');
    const exportStatsBtn = document.getElementById('exportStatsBtn');
    const debugToggleBtn = document.getElementById('debugToggleBtn');
    const video = document.getElementById('video');
    const toast = document.getElementById('toast');
    const manualInput = document.getElementById('manualBarcode');
    const manualBtn = document.getElementById('manualBtn');
    const newItemModal = document.getElementById('newItemModal');
    const newItemForm = document.getElementById('newItemForm');
    const newItemBarcode = document.getElementById('newItemBarcode');

    let codeReader = null;
    let currentStream = null;
    let lastText = '';
    let lastAt = 0;
    let pendingBarcode = null;
    let debugVisible = false;
    
    // Frame data tracking
    let frameStats = {
      totalFrames: 0,
      successfulScans: 0,
      failedScans: 0,
      startTime: null,
      lastScanTime: null,
      frameQuality: [],
      failedFrames: []
    };

    // Detect iOS device
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    
    // Check if camera API is supported
    const isCameraSupported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || 
                              !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
    
    // Check if we're on HTTPS (required for camera access)
    const isSecure = window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    // Frame quality analysis functions
    function analyzeFrameQuality(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      let totalBrightness = 0;
      let totalContrast = 0;
      
      // Calculate brightness and contrast
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        totalBrightness += brightness;
      }
      
      const avgBrightness = totalBrightness / (data.length / 4);
      
      // Calculate contrast (standard deviation of brightness)
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        totalContrast += Math.pow(brightness - avgBrightness, 2);
      }
      
      const contrast = Math.sqrt(totalContrast / (data.length / 4));
      
      // Simple blur detection (edge detection)
      let edgeCount = 0;
      for (let y = 1; y < canvas.height - 1; y++) {
        for (let x = 1; x < canvas.width - 1; x++) {
          const idx = (y * canvas.width + x) * 4;
          const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
          const down = (data[idx + canvas.width * 4] + data[idx + canvas.width * 4 + 1] + data[idx + canvas.width * 4 + 2]) / 3;
          
          const edgeX = Math.abs(center - right);
          const edgeY = Math.abs(center - down);
          
          if (edgeX > 30 || edgeY > 30) {
            edgeCount++;
          }
        }
      }
      
      const blurScore = 1 - (edgeCount / (canvas.width * canvas.height));
      
      return {
        brightness: Math.round(avgBrightness),
        contrast: Math.round(contrast),
        blurScore: Math.round(blurScore * 100) / 100,
        timestamp: Date.now(),
        dimensions: `${canvas.width}x${canvas.height}`
      };
    }
    
    function saveFailedFrame(canvas, quality, error) {
      const frameData = {
        quality: quality,
        error: error,
        timestamp: Date.now(),
        dataUrl: canvas.toDataURL('image/jpeg', 0.8)
      };
      
      frameStats.failedFrames.push(frameData);
      
      // Keep only last 10 failed frames to prevent memory issues
      if (frameStats.failedFrames.length > 10) {
        frameStats.failedFrames.shift();
      }
    }
    
    function exportFailedFrames() {
      if (frameStats.failedFrames.length === 0) {
        showToast('No failed frames to export', 'warning');
        return;
      }
      
      const exportData = {
        summary: {
          totalFailed: frameStats.failedFrames.length,
          timeRange: `${new Date(frameStats.failedFrames[0].timestamp).toLocaleTimeString()} - ${new Date(frameStats.failedFrames[frameStats.failedFrames.length - 1].timestamp).toLocaleTimeString()}`,
          exportTime: new Date().toISOString()
        },
        frames: frameStats.failedFrames
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `failed-frames-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast(`Exported ${frameStats.failedFrames.length} failed frames`, 'success');
    }
    
    function exportFrameStats() {
      const exportData = {
        summary: {
          totalFrames: frameStats.totalFrames,
          successfulScans: frameStats.successfulScans,
          failedScans: frameStats.failedScans,
          startTime: frameStats.startTime ? new Date(frameStats.startTime).toISOString() : null,
          lastScanTime: frameStats.lastScanTime ? new Date(frameStats.lastScanTime).toISOString() : null,
          exportTime: new Date().toISOString()
        },
        frameQuality: frameStats.frameQuality,
        failedFrames: frameStats.failedFrames
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `frame-stats-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast(`Exported complete frame statistics`, 'success');
    }
    
    // Test ZXing library on page load
    function testZXingLibrary() {
      console.log('Testing ZXing library...');
      if (typeof ZXing === 'undefined') {
        console.error('ZXing library not loaded');
        showToast('Barcode library not loaded!', 'error');
        return false;
      }
      
      if (typeof ZXing.BrowserMultiFormatReader === 'undefined') {
        console.error('BrowserMultiFormatReader not available');
        showToast('Barcode reader not available!', 'error');
        return false;
      }
      
      // Test if we can create an instance
      try {
        const testReader = new ZXing.BrowserMultiFormatReader();
        console.log('ZXing library loaded successfully');
        console.log('Available ZXing classes:', Object.keys(ZXing));
        console.log('BrowserMultiFormatReader methods:', Object.getOwnPropertyNames(testReader));
        return true;
      } catch (e) {
        console.error('Failed to create BrowserMultiFormatReader instance:', e);
        showToast('Barcode reader initialization failed!', 'error');
        return false;
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Page loaded, initializing...');
      
      // Test ZXing library
      if (!testZXingLibrary()) {
        return;
      }
      
      // Check browser compatibility
      console.log('Browser compatibility check:');
      console.log('- User Agent:', navigator.userAgent);
      console.log('- Camera API supported:', isCameraSupported);
      console.log('- Secure context:', isSecure);
      console.log('- iOS device:', isIOS);
      console.log('- navigator.mediaDevices:', !!navigator.mediaDevices);
      if (navigator.mediaDevices) {
        console.log('- getUserMedia supported:', !!navigator.mediaDevices.getUserMedia);
      }
      
      // Check camera support and show/hide buttons accordingly
      if (!isCameraSupported) {
        console.log('Camera API not supported');
        showToast('Camera not supported in this browser. Use manual entry.', 'warning');
        // Hide camera-related buttons
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('permissionBtn').style.display = 'none';
        document.getElementById('testVideoBtn').style.display = 'none';
      }
      
      if (!isSecure) {
        console.log('Not on HTTPS - camera access may be limited');
        showToast('Camera access requires HTTPS. Use manual entry or access via your computer\'s IP address.', 'warning');
      }
    });

    function isScannerRunning() {
      return codeReader && codeReader.isScanning !== false;
    }
    
    function updateDebugInfo() {
      const debugInfo = document.getElementById('debugInfo');
      const cameraStatus = document.getElementById('cameraStatus');
      const videoStatus = document.getElementById('videoStatus');
      const scannerStatus = document.getElementById('scannerStatus');
      const frameStatsElement = document.getElementById('frameStats');
      const qualityStatsElement = document.getElementById('qualityStats');
      
      if (debugVisible) {
        debugInfo.style.display = 'block';
        cameraStatus.textContent = `Camera: ${currentStream ? 'Active' : 'Inactive'}`;
        videoStatus.textContent = `Video: ${video.srcObject ? 'Streaming' : 'No Stream'} (${video.videoWidth}x${video.videoHeight})`;
        scannerStatus.textContent = `Scanner: ${isScannerRunning() ? 'Running' : 'Stopped'}`;
        
        // Frame statistics
        if (frameStats.startTime) {
          const runtime = Math.round((Date.now() - frameStats.startTime) / 1000);
          const successRate = frameStats.totalFrames > 0 ? Math.round((frameStats.successfulScans / frameStats.totalFrames) * 100) : 0;
          frameStatsElement.textContent = `Frames: ${frameStats.totalFrames} | Success: ${frameStats.successfulScans} | Failed: ${frameStats.failedScans} | Rate: ${successRate}% | Runtime: ${runtime}s`;
        } else {
          frameStatsElement.textContent = 'Frame Stats: Not started';
        }
        
        // Quality statistics
        if (frameStats.frameQuality.length > 0) {
          const latest = frameStats.frameQuality[frameStats.frameQuality.length - 1];
          const avgBrightness = Math.round(frameStats.frameQuality.reduce((sum, q) => sum + q.brightness, 0) / frameStats.frameQuality.length);
          const avgContrast = Math.round(frameStats.frameQuality.reduce((sum, q) => sum + q.contrast, 0) / frameStats.frameQuality.length);
          qualityStatsElement.textContent = `Quality: B${avgBrightness} C${avgContrast} | Latest: B${latest.brightness} C${latest.contrast} Blur${latest.blurScore}`;
        } else {
          qualityStatsElement.textContent = 'Quality: No data';
        }
        
        // Add more detailed info
        if (video.srcObject) {
          const tracks = currentStream?.getVideoTracks();
          if (tracks && tracks.length > 0) {
            const track = tracks[0];
            const settings = track.getSettings();
            console.log('Video track settings:', settings);
          }
        }
      } else {
        debugInfo.style.display = 'none';
      }
    }

    function toggleDebug() {
      debugVisible = !debugVisible;
      updateDebugInfo();
      debugToggleBtn.textContent = debugVisible ? 'Hide Debug' : 'Debug Info';
    }

    // Polyfill for older browsers
    function getUserMediaPolyfill(constraints) {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        return navigator.mediaDevices.getUserMedia(constraints);
      }
      
      // Fallback for older browsers
      const getUserMedia = navigator.getUserMedia || 
                          navigator.webkitGetUserMedia || 
                          navigator.mozGetUserMedia || 
                          navigator.msGetUserMedia;
      
      if (!getUserMedia) {
        return Promise.reject(new Error('getUserMedia not supported'));
      }
      
      return new Promise((resolve, reject) => {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    }

    function showToast(msg, type='success') {
      toast.textContent = msg;
      toast.className = `toast ${type}`;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, 3000);
    }

    function showNewItemModal(barcode) {
      pendingBarcode = barcode;
      newItemBarcode.textContent = barcode;
      newItemModal.style.display = 'block';
      document.getElementById('itemName').focus();
    }

    function closeNewItemModal() {
      newItemModal.style.display = 'none';
      pendingBarcode = null;
      newItemForm.reset();
    }

    async function postScan(barcode) {
      try {
        const res = await fetch('/api/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ barcode, increment: 1 })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const result = await res.json();
        
        if (result.is_new) {
          showToast(`New barcode detected: ${barcode}`, 'warning');
          showNewItemModal(barcode);
        } else {
          showToast(`Added: ${result.item.name || result.item.barcode} (qty ${result.item.quantity})`);
        }
      } catch (e) {
        console.error(e);
        showToast('Error adding item', 'error');
      }
    }

    async function createNewItem(formData) {
      try {
        console.log('Submitting form data:', formData);
        
        const res = await fetch('/api/items/new', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({}));
          console.error('Server error:', errorData);
          throw new Error(`HTTP ${res.status}: ${errorData.detail || 'Unknown error'}`);
        }
        
        const item = await res.json();
        showToast(`Added: ${item.name} (qty ${item.quantity})`);
        closeNewItemModal();
      } catch (e) {
        console.error('Error creating item:', e);
        showToast(`Error: ${e.message}`, 'error');
      }
    }

    async function testVideo() {
      try {
        console.log('Testing video element...');
        showToast('Testing video...', 'warning');
        
        // Only stop scanner if it's actually running
        if (codeReader && codeReader.isScanning) {
          console.log('Stopping existing scanner for video test...');
          await stopScanning();
        }
        
        const stream = await getUserMediaPolyfill({ 
          video: {
            facingMode: 'environment', // Use back camera on mobile
            width: { ideal: 1280, min: 640 },
            height: { ideal: 720, min: 480 },
            frameRate: { ideal: 30, min: 15 }
          }
        });
        
        video.srcObject = stream;
        currentStream = stream;
        
        // Make video visible and add visual feedback
        video.style.display = 'block';
        video.classList.add('testing');
        video.classList.remove('error');
        
        // Wait for video to be ready
        await new Promise((resolve) => {
          video.onloadedmetadata = () => {
            console.log('Video metadata loaded');
            video.play().then(() => {
              showToast('Video test successful! Ready for scanning.', 'success');
              console.log('Video test successful');
              updateDebugInfo();
              resolve();
            }).catch(resolve);
          };
          video.onerror = (e) => {
            console.error('Video error:', e);
            video.classList.add('error');
            video.classList.remove('testing');
            showToast('Video error: ' + e.message, 'error');
            resolve();
          };
        });
        
      } catch (error) {
        console.error('Video test failed:', error);
        video.classList.add('error');
        video.classList.remove('testing');
        showToast('Video test failed: ' + error.message, 'error');
      }
    }

    async function testBarcode() {
      try {
        showToast('Testing barcode detection...', 'warning');
        
        // Simulate a barcode detection to test the pipeline
        const testBarcode = '1234567890123';
        console.log('Testing barcode detection with:', testBarcode);
        
        // Simulate the detection callback
        if (typeof postScan === 'function') {
          await postScan(testBarcode);
          showToast('Barcode detection test successful!', 'success');
        } else {
          showToast('postScan function not available', 'error');
        }
      } catch (e) {
        console.error('Barcode test failed:', e);
        showToast('Barcode test failed: ' + e.message, 'error');
      }
    }

    async function requestCameraPermission() {
      if (!isCameraSupported) {
        showToast('Camera not supported in this browser. Use manual entry.', 'error');
        return;
      }

      console.log('Requesting camera permission...');
      console.log('Available APIs:', {
        mediaDevices: !!navigator.mediaDevices,
        getUserMedia: !!navigator.getUserMedia,
        webkitGetUserMedia: !!navigator.webkitGetUserMedia,
        mozGetUserMedia: !!navigator.mozGetUserMedia,
        msGetUserMedia: !!navigator.msGetUserMedia
      });

      try {
        showToast('Requesting camera permission...', 'warning');
        
        const stream = await getUserMediaPolyfill({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        video.srcObject = stream;
        currentStream = stream;
        showToast('Camera permission granted!', 'success');
        
        // Stop the stream after permission is granted
        setTimeout(() => {
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
            video.srcObject = null;
          }
        }, 2000);
        
      } catch (error) {
        console.error('Camera permission error:', error);
        if (error.name === 'NotAllowedError') {
          showToast('Camera access denied. Please enable in Settings → Privacy → Camera → Safari', 'error');
        } else if (error.name === 'NotFoundError') {
          showToast('No camera found on this device', 'error');
        } else {
          showToast(`Camera error: ${error.message}`, 'error');
        }
      }
    }

    async function startScanning() {
      if (codeReader) {
        showToast('Scanner already running!', 'warning');
        return;
      }
      
      if (!isCameraSupported) {
        showToast('Camera not supported in this browser. Use manual entry.', 'error');
        return;
      }
      
      // Check if ZXing library is loaded
      if (typeof ZXing === 'undefined') {
        showToast('Barcode library not loaded. Please refresh the page.', 'error');
        console.error('ZXing library not available');
        return;
      }
      
      if (typeof ZXing.BrowserMultiFormatReader === 'undefined') {
        showToast('Barcode reader not available. Please refresh the page.', 'error');
        console.error('BrowserMultiFormatReader not available');
        return;
      }

      // Compatibility check for required methods
      try {
        const testReader = new ZXing.BrowserMultiFormatReader();
        const requiredMethods = ['decodeFromVideoElement', 'reset'];
        const missingMethods = requiredMethods.filter(method => typeof testReader[method] !== 'function');
        
        if (missingMethods.length > 0) {
          showToast(`Scanner incompatible: Missing methods: ${missingMethods.join(', ')}`, 'error');
          console.error('Missing required methods:', missingMethods);
          return;
        }
        
        // Check if decodeFromVideoElement exists and is callable
        if (typeof testReader.decodeFromVideoElement !== 'function') {
          showToast('Scanner incompatible: decodeFromVideoElement method not available', 'error');
          console.error('decodeFromVideoElement method not available');
          return;
        }
        
        // Log method signature for debugging
        console.log('decodeFromVideoElement method signature:', testReader.decodeFromVideoElement.length, 'parameters');
        console.log('decodeFromVideoElement method:', testReader.decodeFromVideoElement.toString().substring(0, 100) + '...');
        console.log('ZXing library version info:', {
          BrowserMultiFormatReader: typeof ZXing.BrowserMultiFormatReader,
          decodeFromVideoElement: typeof testReader.decodeFromVideoElement,
          methodLength: testReader.decodeFromVideoElement.length
        });
        
        // Check for alternative methods if decodeFromVideoElement has issues
        const alternativeMethods = ['decodeFromConstraints', 'decodeFromStream', 'decodeFromVideoDevice'];
        const availableAlternatives = alternativeMethods.filter(method => typeof testReader[method] === 'function');
        if (availableAlternatives.length > 0) {
          console.log('Available alternative methods:', availableAlternatives);
        }
        
        console.log('Compatibility check passed');
      } catch (e) {
        showToast('Scanner compatibility check failed: ' + e.message, 'error');
        console.error('Compatibility check failed:', e);
        return;
      }

      try {
        console.log('Starting scanning process...');
        showToast('Starting scanner...', 'warning');
        
        // Check if we already have a video stream
        if (!video.srcObject || !currentStream) {
          showToast('Please test video first, then start scanning.', 'error');
          return;
        }
        
        // Initialize the barcode reader
        console.log('Initializing barcode reader...');
        codeReader = new ZXing.BrowserMultiFormatReader();
        
        // Start decoding from the existing video element
        console.log('Starting barcode decoding from video element...');
        console.log('Video element:', video);
        console.log('Video srcObject:', video.srcObject);
        console.log('Video readyState:', video.readyState);
        console.log('Video videoWidth:', video.videoWidth);
        console.log('Video videoHeight:', video.videoHeight);
        
        // Add a small delay to ensure video is fully ready
        setTimeout(() => {
          console.log('Starting barcode detection...');
          
          // Add frame processing indicator
          let frameCount = 0;
          const frameInterval = setInterval(() => {
            frameCount++;
            if (frameCount % 30 === 0) { // Log every 30 frames (about once per second)
              console.log(`Scanner processing frames: ${frameCount} frames processed`);
            }
          }, 33); // ~30fps
          
          // Debug: Log available methods on codeReader
          console.log('Available codeReader methods:', Object.getOwnPropertyNames(codeReader));
          console.log('codeReader prototype methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(codeReader)));
          
          // Test different decoding methods
          console.log('Testing decodeFromImage method:', typeof codeReader.decodeFromImage);
          console.log('Testing decodeFromCanvas method:', typeof codeReader.decodeFromCanvas);
          console.log('Testing decodeFromVideoElement method:', typeof codeReader.decodeFromVideoElement);
          
          // Try to get more detailed method info
          if (codeReader.decodeFromImage) {
            console.log('decodeFromImage method signature:', codeReader.decodeFromImage.length, 'parameters');
            console.log('decodeFromImage toString:', codeReader.decodeFromImage.toString().substring(0, 150));
          }
          
          // Start continuous scanning with a more robust approach
          console.log('Starting continuous barcode scanning...');
          
          // Initialize frame stats
          frameStats.startTime = Date.now();
          frameStats.totalFrames = 0;
          frameStats.successfulScans = 0;
          frameStats.failedScans = 0;
          frameStats.frameQuality = [];
          
          // Use a polling approach that's more reliable than ZXing's built-in methods
          let isScanning = true;
          let scanCount = 0;
          const scanInterval = setInterval(async () => {
            if (!isScanning || !codeReader || !video.srcObject) {
              clearInterval(scanInterval);
              return;
            }
            
            scanCount++;
            frameStats.totalFrames++;
            
            if (scanCount % 10 === 0) { // Log every 10 scans (about every 5 seconds)
              console.log(`Scanner active: ${scanCount} scans performed`);
              console.log(`Frame stats: Total: ${frameStats.totalFrames}, Success: ${frameStats.successfulScans}, Failed: ${frameStats.failedScans}`);
            }
            
            try {
              // Capture current frame
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              
              // Draw current video frame
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              
              // Analyze frame quality
              const quality = analyzeFrameQuality(canvas);
              frameStats.frameQuality.push(quality);
              
              // Keep only last 100 quality measurements to prevent memory issues
              if (frameStats.frameQuality.length > 100) {
                frameStats.frameQuality.shift();
              }
              
              // Try to decode the frame using multiple methods
              let decodeResult = null;
              
              // Method 1: Try decodeFromImage (most reliable for canvas)
              if (typeof codeReader.decodeFromImage === 'function') {
                try {
                  decodeResult = await codeReader.decodeFromImage(canvas);
                  if (decodeResult) {
                    console.log('Barcode detected via decodeFromImage:', decodeResult.getText());
                  }
                } catch (e) {
                  if (e.name !== 'NotFoundException') {
                    console.log('decodeFromImage error:', e.name, e.message);
                  }
                }
              }
              
              // Method 2: Try decodeFromCanvas if available
              if (!decodeResult && typeof codeReader.decodeFromCanvas === 'function') {
                try {
                  decodeResult = await codeReader.decodeFromCanvas(canvas);
                  if (decodeResult) {
                    console.log('Barcode detected via decodeFromCanvas:', decodeResult.getText());
                  }
                } catch (e) {
                  if (e.name !== 'NotFoundException') {
                    console.log('decodeFromCanvas error:', e.name, e.message);
                  }
                }
              }
              
              // Method 3: Try decodeFromVideoElement with a single frame
              if (!decodeResult && typeof codeReader.decodeFromVideoElement === 'function') {
                try {
                  // Create a temporary video element with the current frame
                  const tempVideo = document.createElement('video');
                  tempVideo.srcObject = video.srcObject;
                  tempVideo.currentTime = video.currentTime;
                  
                  decodeResult = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout')), 1000);
                    codeReader.decodeFromVideoElement(tempVideo, (result, error) => {
                      clearTimeout(timeout);
                      if (error && error.name !== 'NotFoundException') {
                        reject(error);
                      } else {
                        resolve(result);
                      }
                    });
                  });
                  
                  if (decodeResult) {
                    console.log('Barcode detected via decodeFromVideoElement:', decodeResult.getText());
                  }
                } catch (e) {
                  if (e.name !== 'NotFoundException') {
                    console.log('decodeFromVideoElement error:', e.name, e.message);
                  }
                }
              }
              
              // Process result if any method succeeded
              if (decodeResult) {
                const text = decodeResult.getText();
                console.log('Barcode detected via polling:', text);
                console.log('Frame quality at detection:', quality);
                
                const now = Date.now();
                // Deduplicate rapid repeats
                if (text && (text !== lastText || now - lastAt > 1500)) {
                  lastText = text; 
                  lastAt = now;
                  frameStats.lastScanTime = now;
                  frameStats.successfulScans++;
                  
                  postScan(text);
                  showToast(`Barcode detected: ${text}`, 'success');
                  
                  // Add visual feedback
                  video.style.border = '3px solid #4CAF50';
                  setTimeout(() => {
                    video.style.border = '';
                  }, 2000);
                }
              } else {
                // No barcode found - this is normal
                frameStats.failedScans++;
              }
            } catch (e) {
              console.log('Frame capture error:', e);
              frameStats.failedScans++;
            }
          }, 500); // Check every 500ms
          
          // Store the interval for cleanup
          if (codeReader) {
            codeReader.scanInterval = scanInterval;
            codeReader.isScanning = true;
          }
          
          // Store the interval for cleanup
          if (codeReader) {
            codeReader.frameInterval = frameInterval;
          }
        }, 500);
        
        showToast('Scanner started successfully!', 'success');
        console.log('Scanning started successfully');
        updateDebugInfo();
        
      } catch (e) {
        console.error('Scanning start failed:', e);
        showToast('Failed to start scanning: ' + e.message, 'error');
      }
    }

    async function stopScanning() {
      if (codeReader) {
        try {
          // Stop the scanning loop
          if (codeReader.isScanning !== undefined) {
            codeReader.isScanning = false;
          }
          
          // Clear the scan interval if it exists
          if (codeReader.scanInterval) {
            clearInterval(codeReader.scanInterval);
            codeReader.scanInterval = null;
          }
          
          // Clear the frame interval if it exists (legacy)
          if (codeReader.frameInterval) {
            clearInterval(codeReader.frameInterval);
            codeReader.frameInterval = null;
          }
          
          await codeReader.reset();
          codeReader = null;
          
          // Log final frame statistics
          if (frameStats.startTime) {
            const runtime = Math.round((Date.now() - frameStats.startTime) / 1000);
            const successRate = frameStats.totalFrames > 0 ? Math.round((frameStats.successfulScans / frameStats.totalFrames) * 100) : 0;
            console.log(`Scanner stopped. Final stats: ${frameStats.totalFrames} frames, ${frameStats.successfulScans} successful, ${frameStats.failedScans} failed, ${successRate}% success rate, ${runtime}s runtime`);
          }
          
          showToast('Scanner stopped');
          console.log('Scanner stopped');
          updateDebugInfo();
        } catch (e) {
          console.error('Error stopping scanner:', e);
        }
      }
    }
    
    async function stopVideo() {
      if (currentStream) {
        try {
          currentStream.getTracks().forEach(track => track.stop());
          currentStream = null;
          video.srcObject = null;
          video.style.display = 'none';
          video.classList.remove('testing', 'error');
          showToast('Video stopped');
          console.log('Video stopped');
          updateDebugInfo();
        } catch (e) {
          console.error('Error stopping video:', e);
        }
      }
    }

    async function restartVideo() {
      console.log('Restarting video stream...');
      showToast('Restarting video stream...', 'warning');
      await stopVideo(); // Stop the current stream
      await requestCameraPermission(); // Request permission again
      await startScanning(); // Start scanning with the new stream
      showToast('Video stream restarted successfully!', 'success');
      console.log('Video stream restarted successfully');
      updateDebugInfo();
    }
    
    async function recoverVideoStream() {
      console.log('Attempting to recover video stream...');
      if (currentStream && currentStream.active) {
        try {
          // Reconnect the video element to the existing stream
          video.srcObject = currentStream;
          await new Promise(resolve => {
            video.onloadedmetadata = resolve;
            video.onerror = () => resolve();
            // Timeout after 3 seconds
            setTimeout(resolve, 3000);
          });
          
          if (video.readyState >= 2) {
            console.log('Video stream recovered successfully');
            showToast('Video stream recovered!', 'success');
            return true;
          }
        } catch (e) {
          console.log('Video recovery failed:', e);
        }
      }
      
      // If recovery failed, do full restart
      console.log('Recovery failed, doing full restart...');
      await restartVideo();
      return false;
    }

    async function captureAndDecode() {
      try {
        if (!video.srcObject) {
          showToast('No video stream available', 'error');
          return;
        }
        
        showToast('Capturing frame...', 'warning');
        console.log('Capturing frame for manual decode...');
        
        // Check if video stream is still active
        if (video.readyState === 0) {
          showToast('Video stream not ready, restarting...', 'warning');
          await restartVideo();
          return;
        }
        
        // Create a canvas to capture the current video frame
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Draw the current video frame to canvas
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        console.log('Frame captured, dimensions:', canvas.width, 'x', canvas.height);
        
        // Try different decoding methods
        let decodeResult = null;
        
        // Method 1: Try decodeFromImage (most common)
        if (codeReader && typeof codeReader.decodeFromImage === 'function') {
          try {
            console.log('Trying decodeFromImage...');
            decodeResult = await codeReader.decodeFromImage(canvas);
            console.log('decodeFromImage result:', decodeResult);
          } catch (e) {
            console.log('decodeFromImage failed:', e);
          }
        }
        
        // Method 2: Try decodeFromCanvas if available
        if (!decodeResult && codeReader && typeof codeReader.decodeFromCanvas === 'function') {
          try {
            console.log('Trying decodeFromCanvas...');
            decodeResult = await codeReader.decodeFromCanvas(canvas);
            console.log('decodeFromCanvas result:', decodeResult);
          } catch (e) {
            console.log('decodeFromCanvas failed:', e);
          }
        }
        
        // Method 3: Try decodeFromVideoElement with a single frame
        if (!decodeResult && codeReader && typeof codeReader.decodeFromVideoElement === 'function') {
          try {
            console.log('Trying decodeFromVideoElement with single frame...');
            // Create a temporary video element with the captured frame
            const tempVideo = document.createElement('video');
            tempVideo.width = canvas.width;
            tempVideo.height = canvas.height;
            
            // Convert canvas to blob and create video source
            canvas.toBlob(async (blob) => {
              const videoUrl = URL.createObjectURL(blob);
              tempVideo.src = videoUrl;
              tempVideo.onloadeddata = async () => {
                try {
                  const result = await codeReader.decodeFromVideoElement(tempVideo);
                  if (result) {
                    const text = result.getText();
                    console.log('Single frame decode successful:', text);
                    showToast(`Barcode detected: ${text}`, 'success');
                    postScan(text);
                  } else {
                    showToast('No barcode found in captured frame', 'warning');
                  }
                } catch (e) {
                  console.log('Single frame decode failed:', e);
                  showToast('Manual decode failed: ' + e.message, 'error');
                } finally {
                  URL.revokeObjectURL(videoUrl);
                }
              };
            }, 'image/jpeg');
            return; // Exit early since this is async
          } catch (e) {
            console.log('Single frame decode setup failed:', e);
          }
        }
        
        // Method 4: Try direct canvas decode with different ZXing methods
        if (!decodeResult && codeReader) {
          const alternativeMethods = ['decodeFromCanvas', 'decodeFromImageElement'];
          for (const method of alternativeMethods) {
            if (typeof codeReader[method] === 'function') {
              try {
                console.log(`Trying ${method}...`);
                const result = await codeReader[method](canvas);
                if (result) {
                  decodeResult = result;
                  console.log(`${method} successful:`, result);
                  break;
                }
              } catch (e) {
                console.log(`${method} failed:`, e);
              }
            }
          }
        }
        
        // Check if any method worked
        if (decodeResult) {
          const text = decodeResult.getText();
          console.log('Manual decode successful:', text);
          showToast(`Barcode detected: ${text}`, 'success');
          postScan(text);
        } else {
          console.log('All decode methods failed');
          showToast('No barcode found in captured frame', 'warning');
        }
        
        // Check if video stream is still working after capture (less aggressive)
        setTimeout(async () => {
          if (!video.srcObject || video.readyState === 0) {
            console.log('Video stream interrupted after capture, attempting recovery...');
            await recoverVideoStream();
          }
        }, 2000);
        
      } catch (e) {
        console.error('Capture failed:', e);
        showToast('Capture failed: ' + e.message, 'error');
        
        // Only restart if absolutely necessary
        if (!video.srcObject && !currentStream) {
          console.log('Complete stream loss, attempting recovery...');
          await recoverVideoStream();
        }
      }
    }

    startBtn.addEventListener('click', startScanning);
    stopBtn.addEventListener('click', stopScanning);
    stopVideoBtn.addEventListener('click', stopVideo);
    restartVideoBtn.addEventListener('click', restartVideo);
    recoverVideoBtn.addEventListener('click', recoverVideoStream);
    permissionBtn.addEventListener('click', requestCameraPermission);
    testVideoBtn.addEventListener('click', testVideo);
    testBarcodeBtn.addEventListener('click', testBarcode);
    generateTestBarcodeBtn.addEventListener('click', generateTestBarcode);
    captureBtn.addEventListener('click', captureAndDecode);
    exportFramesBtn.addEventListener('click', exportFailedFrames);
    exportStatsBtn.addEventListener('click', exportFrameStats);
    debugToggleBtn.addEventListener('click', toggleDebug);
    
    manualBtn.addEventListener('click', () => {
      const val = (manualInput.value || '').trim();
      if (!val) return showToast('Enter a barcode', 'error');
      postScan(val);
      manualInput.value = '';
    });

    newItemForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const itemNameInput = document.getElementById('itemName');
      const itemName = itemNameInput.value.trim();
      const itemGame = document.getElementById('itemGame').value || null;
      const itemSet = document.getElementById('itemSet').value || null;
      const itemNumber = document.getElementById('itemNumber').value || null;
      const itemQuantity = parseInt(document.getElementById('itemQuantity').value) || 1;
      const itemPrice = parseFloat(document.getElementById('itemPrice').value) || null;
      const itemLocation = document.getElementById('itemLocation').value || null;
      const itemDescription = document.getElementById('itemDescription').value || null;
      const itemNotes = document.getElementById('itemNotes').value || null;

      if (!itemName) {
        showToast('Item name cannot be empty.', 'error');
        return;
      }

      if (!pendingBarcode) {
        showToast('No barcode found. Please scan again.', 'error');
        return;
      }

      const formData = {
        barcode: pendingBarcode,
        name: itemName,
        game: itemGame,
        set_name: itemSet,
        number_in_set: itemNumber,
        quantity: itemQuantity,
        location: itemLocation,
        notes: itemNotes,
        price: itemPrice,
        description: itemDescription,
      };
      
      await createNewItem(formData);
    });

    // Close modal when clicking outside
    newItemModal.addEventListener('click', (e) => {
      if (e.target === newItemModal) {
        closeNewItemModal();
      }
    });
  </script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Card Inventory Scanner</title>
  <style>
    body { 
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
      margin: 0; 
      padding: 0; 
      background: #0b0c10; 
      color: #eaf0f6; 
      min-height: 100vh;
    }
    
    header { 
      padding: 12px 16px; 
      text-align: center; 
      background: #1f2833; 
      position: sticky; 
      top: 0; 
      z-index: 1; 
    }
    
    header h2 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    main { 
      padding: 12px; 
      max-width: 100%;
      margin: 0 auto;
    }
    
    @media (min-width: 768px) {
      main {
        padding: 16px;
        max-width: 600px;
      }
      
      header h2 {
        font-size: 2rem;
      }
    }
    
    .card { 
      background: #14171a; 
      border-radius: 12px; 
      padding: 16px; 
      box-shadow: 0 2px 12px rgba(0,0,0,.35); 
      margin-bottom: 16px; 
    }
    
    .grid { 
      display: grid; 
      gap: 12px; 
    }
    
    video { 
      width: 100%; 
      max-height: 40vh; 
      background: #000; 
      border-radius: 10px; 
      border: 2px solid #333; 
    }
    
    @media (max-width: 767px) {
      video {
        max-height: 35vh;
      }
    }
    video.testing { border: 2px solid #45a29e; background: #1a1a1a; box-shadow: 0 0 10px rgba(69, 162, 158, 0.5); }
    video.error { border: 2px solid #e74c3c; background: #2a1a1a; box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
    video:not([srcObject]) { background: #1a1a1a; border: 2px dashed #666; }
    button { 
      font-size: 16px; 
      padding: 12px 16px; 
      border: none; 
      border-radius: 10px; 
      background: #45a29e; 
      color: #0b0c10; 
      font-weight: 700; 
      cursor: pointer; 
      min-height: 44px; /* iOS touch target minimum */
      touch-action: manipulation;
    }
    
    button.secondary { background: #c5c6c7; color: #0b0c10; }
    button.danger { background: #e74c3c; color: white; }
    button.success { background: #27ae60; color: white; }
    
    /* Mobile button grid */
    .button-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 480px) {
      .button-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (min-width: 768px) {
      .button-grid {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
      }
    }
    input[type="text"], input[type="number"], textarea, select { 
      width: 100%; 
      padding: 12px; 
      font-size: 16px; 
      border-radius: 8px; 
      border: 1px solid #334; 
      background: #0f1113; 
      color: #eaf0f6; 
      margin-bottom: 12px; 
      box-sizing: border-box;
      -webkit-appearance: none;
      border-radius: 8px;
    }
    
    textarea { 
      resize: vertical; 
      min-height: 80px; 
    }
    
    select {
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .row { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
    }
    
    .toast { 
      margin-top: 8px; 
      padding: 12px; 
      border-radius: 8px; 
      background: #173f2a; 
      color: #b7ffd8; 
      display: none; 
      font-size: 14px;
    }
    .error { background: #3f1717; color: #ffb7b7; }
    .warning { background: #3f2f17; color: #ffd7b7; }
    .muted { color: #9aa5b1; font-size: 14px; }
    .small { font-size: 12px; }
    a { color: #66fcf1; }
    .form-group { margin-bottom: 12px; }
    .form-group label { display: block; margin-bottom: 4px; font-weight: 600; }
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; }
    .modal-content { 
      position: relative; 
      background: #14171a; 
      margin: 10px; 
      padding: 20px; 
      border-radius: 12px; 
      max-width: 500px; 
      max-height: 90vh; 
      overflow-y: auto; 
    }
    
    @media (min-width: 768px) {
      .modal-content {
        margin: 20px auto;
      }
    }
    
    .close { 
      position: absolute; 
      top: 10px; 
      right: 15px; 
      font-size: 24px; 
      cursor: pointer; 
      color: #9aa5b1; 
      padding: 8px;
      min-height: 44px;
      min-width: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .close:hover { color: #eaf0f6; }
    .hidden { display: none; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .flex-1 { flex: 1; }
    .gap-2 { gap: 8px; }
    .mb-2 { margin-bottom: 8px; }
    .mb-4 { margin-bottom: 16px; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
  <script>
    // Check if QuaggaJS loaded successfully
    if (typeof Quagga === 'undefined') {
      console.error('QuaggaJS library failed to load');
    } else {
      console.log('QuaggaJS library loaded successfully');
    }
  </script>
</head>
<body>
  <header>
    <h2>Card Inventory</h2>
  </header>
  <main class="grid">
    <section class="card">
      <div class="grid">
        <video id="video" playsinline autoplay muted></video>
        <div class="button-grid">
          <button id="startBtn">Start Scanning</button>
          <button id="stopBtn" class="secondary">Stop Scanner</button>
          <button id="stopVideoBtn" class="secondary">Stop Video</button>
          <button id="restartVideoBtn" class="secondary">Restart Video</button>
          <button id="recoverVideoBtn" class="secondary">Recover Video</button>
          <button id="permissionBtn" class="secondary">Request Camera Permission</button>
          <button id="testVideoBtn" class="secondary">Test Video</button>
          <button id="testBarcodeBtn" class="secondary">Test Barcode</button>
        <button id="generateTestBarcodeBtn" class="secondary">Generate Test Barcode</button>
          <button id="captureBtn" class="secondary">Capture & Decode</button>
          <button id="exportFramesBtn" class="secondary">Export Failed Frames</button>
          <button id="exportStatsBtn" class="secondary">Export All Stats</button>
          <button id="debugToggleBtn" class="secondary">Debug Info</button>
        </div>
        <div class="muted small">
          <strong>iPhone Camera Issues?</strong><br>
          • Use Safari (not Chrome)<br>
          • Go to Settings → Privacy → Camera → Safari<br>
          • Try adding to Home Screen<br>
          • Use manual entry below as backup
        </div>
        <div id="debugInfo" class="muted small" style="display: none;">
          <strong>Debug Info:</strong><br>
          <span id="cameraStatus">Camera: Unknown</span><br>
          <span id="videoStatus">Video: Unknown</span><br>
          <span id="scannerStatus">Scanner: Unknown</span><br>
          <span id="frameStats">Frame Stats: Unknown</span><br>
          <span id="qualityStats">Quality: Unknown</span>
        </div>
        <div id="toast" class="toast"></div>
      </div>
    </section>

    <section class="card">
      <h3>Manual Entry</h3>
      <div class="form-group">
        <input type="text" id="manualBarcode" placeholder="Enter barcode (UPC/EAN)" inputmode="numeric" />
      </div>
      <div class="form-group">
        <button id="manualBtn">Add</button>
      </div>
    </section>

    <section class="card">
      <h3>Tips</h3>
      <ul>
        <li>Add this page to Home Screen in Safari.</li>
        <li>Good lighting improves scan reliability.</li>
        <li>Use landscape if autofocus struggles.</li>
        <li>New items will prompt for additional details.</li>
      </ul>
      <div class="small muted">API: <a href="/docs">Swagger</a></div>
    </section>
  </main>

  <!-- New Item Modal -->
  <div id="newItemModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeNewItemModal()">&times;</span>
      <h3>Add New Item</h3>
      <p class="muted">Barcode: <span id="newItemBarcode"></span></p>
      
      <form id="newItemForm">
        <div class="form-group">
          <label for="itemName">Name</label>
          <input type="text" id="itemName" placeholder="Card name">
        </div>
        
        <div class="form-group">
          <label for="itemGame">Game</label>
          <select id="itemGame">
            <option value="">Select game...</option>
            <option value="Pokémon">Pokémon</option>
            <option value="Magic: The Gathering">Magic: The Gathering</option>
            <option value="Yu-Gi-Oh!">Yu-Gi-Oh!</option>
            <option value="NFL">NFL</option>
            <option value="NBA">NBA</option>
            <option value="MLB">MLB</option>
            <option value="WNBA">WNBA</option>
            <option value="Hockey">Hockey</option>
            <option value="College">College</option>
            <option value="MMA">MMA</option>
            <option value="Soccer">Soccer</option>
            <option value="Other">Other</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="itemSet">Set</label>
          <input type="text" id="itemSet" placeholder="Set name">
        </div>
        <div class="form-group">
          <label for="itemNumber">Number</label>
          <input type="text" id="itemNumber" placeholder="Card number">
        </div>
        
        <div class="form-group">
          <label for="itemQuantity">Quantity</label>
          <input type="number" id="itemQuantity" value="1" min="1">
        </div>
        
        <div class="form-group">
          <label for="itemPrice">Price ($)</label>
          <input type="number" id="itemPrice" step="0.01" min="0" placeholder="0.00">
        </div>
        
        <div class="form-group">
          <label for="itemLocation">Location</label>
          <input type="text" id="itemLocation" placeholder="Binder, box, etc.">
        </div>
        
        <div class="form-group">
          <label for="itemDescription">Description</label>
          <textarea id="itemDescription" placeholder="Additional details about the card..."></textarea>
        </div>
        
        <div class="form-group">
          <label for="itemNotes">Notes</label>
          <textarea id="itemNotes" placeholder="Personal notes..."></textarea>
        </div>
        
        <div class="form-group">
          <button type="submit" class="success">Add Item</button>
        </div>
        <div class="form-group">
          <button type="button" class="secondary" onclick="closeNewItemModal()">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stopVideoBtn = document.getElementById('stopVideoBtn');
    const restartVideoBtn = document.getElementById('restartVideoBtn');
    const recoverVideoBtn = document.getElementById('recoverVideoBtn');
    const permissionBtn = document.getElementById('permissionBtn');
    const testVideoBtn = document.getElementById('testVideoBtn');
    const testBarcodeBtn = document.getElementById('testBarcodeBtn');
    const generateTestBarcodeBtn = document.getElementById('generateTestBarcodeBtn');
    const captureBtn = document.getElementById('captureBtn');
    const exportFramesBtn = document.getElementById('exportFramesBtn');
    const exportStatsBtn = document.getElementById('exportStatsBtn');
    const debugToggleBtn = document.getElementById('debugToggleBtn');
    const video = document.getElementById('video');
    const toast = document.getElementById('toast');
    const manualInput = document.getElementById('manualBarcode');
    const manualBtn = document.getElementById('manualBtn');
    const newItemModal = document.getElementById('newItemModal');
    const newItemForm = document.getElementById('newItemForm');
    const newItemBarcode = document.getElementById('newItemBarcode');

    let codeReader = null;
    let currentStream = null;
    let lastText = '';
    let lastAt = 0;
    let pendingBarcode = null;
    let debugVisible = false;
    let isScanning = false;
    
    // Frame data tracking
    let frameStats = {
      totalFrames: 0,
      successfulScans: 0,
      failedScans: 0,
      startTime: null,
      lastScanTime: null,
      frameQuality: [],
      failedFrames: []
    };

    // Detect iOS device
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    
    // Check if camera API is supported
    const isCameraSupported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || 
                              !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
    
    // Check if we're on HTTPS (required for camera access)
    const isSecure = window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    // Frame quality analysis functions
    function analyzeFrameQuality(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      let totalBrightness = 0;
      let totalContrast = 0;
      
      // Calculate brightness and contrast
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        totalBrightness += brightness;
      }
      
      const avgBrightness = totalBrightness / (data.length / 4);
      
      // Calculate contrast (standard deviation of brightness)
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        totalContrast += Math.pow(brightness - avgBrightness, 2);
      }
      
      const contrast = Math.sqrt(totalContrast / (data.length / 4));
      
      // Simple blur detection (edge detection)
      let edgeCount = 0;
      for (let y = 1; y < canvas.height - 1; y++) {
        for (let x = 1; x < canvas.width - 1; x++) {
          const idx = (y * canvas.width + x) * 4;
          const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
          const down = (data[idx + canvas.width * 4] + data[idx + canvas.width * 4 + 1] + data[idx + canvas.width * 4 + 2]) / 3;
          
          const edgeX = Math.abs(center - right);
          const edgeY = Math.abs(center - down);
          
          if (edgeX > 30 || edgeY > 30) {
            edgeCount++;
          }
        }
      }
      
      const blurScore = 1 - (edgeCount / (canvas.width * canvas.height));
      
      return {
        brightness: Math.round(avgBrightness),
        contrast: Math.round(contrast),
        blurScore: Math.round(blurScore * 100) / 100,
        timestamp: Date.now(),
        dimensions: `${canvas.width}x${canvas.height}`
      };
    }
    
    function saveFailedFrame(canvas, quality, error) {
      const frameData = {
        quality: quality,
        error: error,
        timestamp: Date.now(),
        dataUrl: canvas.toDataURL('image/jpeg', 0.8)
      };
      
      frameStats.failedFrames.push(frameData);
      
      // Keep only last 10 failed frames to prevent memory issues
      if (frameStats.failedFrames.length > 10) {
        frameStats.failedFrames.shift();
      }
    }
    
    function exportFailedFrames() {
      if (frameStats.failedFrames.length === 0) {
        showToast('No failed frames to export', 'warning');
        return;
      }
      
      const exportData = {
        summary: {
          totalFailed: frameStats.failedFrames.length,
          timeRange: `${new Date(frameStats.failedFrames[0].timestamp).toLocaleTimeString()} - ${new Date(frameStats.failedFrames[frameStats.failedFrames.length - 1].timestamp).toLocaleTimeString()}`,
          exportTime: new Date().toISOString()
        },
        frames: frameStats.failedFrames
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `failed-frames-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast(`Exported ${frameStats.failedFrames.length} failed frames`, 'success');
    }
    
    function exportFrameStats() {
      const exportData = {
        summary: {
          totalFrames: frameStats.totalFrames,
          successfulScans: frameStats.successfulScans,
          failedScans: frameStats.failedScans,
          startTime: frameStats.startTime ? new Date(frameStats.startTime).toISOString() : null,
          lastScanTime: frameStats.lastScanTime ? new Date(frameStats.lastScanTime).toISOString() : null,
          exportTime: new Date().toISOString()
        },
        frameQuality: frameStats.frameQuality,
        failedFrames: frameStats.failedFrames
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `frame-stats-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast(`Exported complete frame statistics`, 'success');
    }
    
    // Test QuaggaJS library on page load
    function testQuaggaLibrary() {
      console.log('Testing QuaggaJS library...');
      if (typeof Quagga === 'undefined') {
        console.error('QuaggaJS library not loaded');
        showToast('Barcode library not loaded!', 'error');
        return false;
      }
      
      // Test if we can access Quagga methods
      try {
        console.log('QuaggaJS library loaded successfully');
        console.log('Available Quagga methods:', Object.getOwnPropertyNames(Quagga));
        return true;
      } catch (e) {
        console.error('Failed to access QuaggaJS methods:', e);
        showToast('Barcode reader initialization failed!', 'error');
        return false;
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Page loaded, initializing...');
      
      // Test QuaggaJS library
      if (!testQuaggaLibrary()) {
        return;
      }
      
      // Check browser compatibility
      console.log('Browser compatibility check:');
      console.log('- User Agent:', navigator.userAgent);
      console.log('- Camera API supported:', isCameraSupported);
      console.log('- Secure context:', isSecure);
      console.log('- iOS device:', isIOS);
      console.log('- navigator.mediaDevices:', !!navigator.mediaDevices);
      if (navigator.mediaDevices) {
        console.log('- getUserMedia supported:', !!navigator.mediaDevices.getUserMedia);
      }
      
      // Check camera support and show/hide buttons accordingly
      if (!isCameraSupported) {
        console.log('Camera API not supported');
        showToast('Camera not supported in this browser. Use manual entry.', 'warning');
        // Hide camera-related buttons
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('permissionBtn').style.display = 'none';
        document.getElementById('testVideoBtn').style.display = 'none';
      }
      
      if (!isSecure) {
        console.log('Not on HTTPS - camera access may be limited');
        showToast('Camera access requires HTTPS. Use manual entry or access via your computer\'s IP address.', 'warning');
      }
    });

    function isScannerRunning() {
      return isScanning;
    }
    
    function updateDebugInfo() {
      const debugInfo = document.getElementById('debugInfo');
      const cameraStatus = document.getElementById('cameraStatus');
      const videoStatus = document.getElementById('videoStatus');
      const scannerStatus = document.getElementById('scannerStatus');
      const frameStatsElement = document.getElementById('frameStats');
      const qualityStatsElement = document.getElementById('qualityStats');
      
      if (debugVisible) {
        debugInfo.style.display = 'block';
        cameraStatus.textContent = `Camera: ${currentStream ? 'Active' : 'Inactive'}`;
        videoStatus.textContent = `Video: ${video.srcObject ? 'Streaming' : 'No Stream'} (${video.videoWidth}x${video.videoHeight})`;
        scannerStatus.textContent = `Scanner: ${isScannerRunning() ? 'Running' : 'Stopped'}`;
        
        // Frame statistics
        if (frameStats.startTime) {
          const runtime = Math.round((Date.now() - frameStats.startTime) / 1000);
          const successRate = frameStats.totalFrames > 0 ? Math.round((frameStats.successfulScans / frameStats.totalFrames) * 100) : 0;
          frameStatsElement.textContent = `Frames: ${frameStats.totalFrames} | Success: ${frameStats.successfulScans} | Failed: ${frameStats.failedScans} | Rate: ${successRate}% | Runtime: ${runtime}s`;
        } else {
          frameStatsElement.textContent = 'Frame Stats: Not started';
        }
        
        // Quality statistics
        if (frameStats.frameQuality.length > 0) {
          const latest = frameStats.frameQuality[frameStats.frameQuality.length - 1];
          const avgBrightness = Math.round(frameStats.frameQuality.reduce((sum, q) => sum + q.brightness, 0) / frameStats.frameQuality.length);
          const avgContrast = Math.round(frameStats.frameQuality.reduce((sum, q) => sum + q.contrast, 0) / frameStats.frameQuality.length);
          qualityStatsElement.textContent = `Quality: B${avgBrightness} C${avgContrast} | Latest: B${latest.brightness} C${latest.contrast} Blur${latest.blurScore}`;
        } else {
          qualityStatsElement.textContent = 'Quality: No data';
        }
        
        // Add more detailed info
        if (video.srcObject) {
          const tracks = currentStream?.getVideoTracks();
          if (tracks && tracks.length > 0) {
            const track = tracks[0];
            const settings = track.getSettings();
            console.log('Video track settings:', settings);
          }
        }
      } else {
        debugInfo.style.display = 'none';
      }
    }

    function toggleDebug() {
      debugVisible = !debugVisible;
      updateDebugInfo();
      debugToggleBtn.textContent = debugVisible ? 'Hide Debug' : 'Debug Info';
    }

    // Polyfill for older browsers
    function getUserMediaPolyfill(constraints) {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        return navigator.mediaDevices.getUserMedia(constraints);
      }
      
      // Fallback for older browsers
      const getUserMedia = navigator.getUserMedia || 
                          navigator.webkitGetUserMedia || 
                          navigator.mozGetUserMedia || 
                          navigator.msGetUserMedia;
      
      if (!getUserMedia) {
        return Promise.reject(new Error('getUserMedia not supported'));
      }
      
      return new Promise((resolve, reject) => {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    }

    function showToast(msg, type='success') {
      toast.textContent = msg;
      toast.className = `toast ${type}`;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, 3000);
    }

    function showNewItemModal(barcode) {
      pendingBarcode = barcode;
      newItemBarcode.textContent = barcode;
      newItemModal.style.display = 'block';
      document.getElementById('itemName').focus();
    }

    function closeNewItemModal() {
      newItemModal.style.display = 'none';
      pendingBarcode = null;
      newItemForm.reset();
    }

    async function postScan(barcode) {
      try {
        const res = await fetch('/api/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ barcode, increment: 1 })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const result = await res.json();
        
        if (result.is_new) {
          showToast(`New barcode detected: ${barcode}`, 'warning');
          showNewItemModal(barcode);
        } else {
          showToast(`Added: ${result.item.name || result.item.barcode} (qty ${result.item.quantity})`);
        }
      } catch (e) {
        console.error(e);
        showToast('Error adding item', 'error');
      }
    }

    async function createNewItem(formData) {
      try {
        console.log('Submitting form data:', formData);
        
        const res = await fetch('/api/items/new', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({}));
          console.error('Server error:', errorData);
          throw new Error(`HTTP ${res.status}: ${errorData.detail || 'Unknown error'}`);
        }
        
        const item = await res.json();
        showToast(`Added: ${item.name} (qty ${item.quantity})`);
        closeNewItemModal();
      } catch (e) {
        console.error('Error creating item:', e);
        showToast(`Error: ${e.message}`, 'error');
      }
    }

    async function testVideo() {
      try {
        console.log('Testing video element...');
        showToast('Testing video...', 'warning');
        
        // Only stop scanner if it's actually running
        if (codeReader && codeReader.isScanning) {
          console.log('Stopping existing scanner for video test...');
          await stopScanning();
        }
        
        const stream = await getUserMediaPolyfill({ 
          video: {
            facingMode: 'environment', // Use back camera on mobile
            width: { ideal: 1280, min: 640 },
            height: { ideal: 720, min: 480 },
            frameRate: { ideal: 30, min: 15 }
          }
        });
        
        video.srcObject = stream;
        currentStream = stream;
        
        // Make video visible and add visual feedback
        video.style.display = 'block';
        video.classList.add('testing');
        video.classList.remove('error');
        
        // Wait for video to be ready
        await new Promise((resolve) => {
          video.onloadedmetadata = () => {
            console.log('Video metadata loaded');
            video.play().then(() => {
              showToast('Video test successful! Ready for scanning.', 'success');
              console.log('Video test successful');
              updateDebugInfo();
              resolve();
            }).catch(resolve);
          };
          video.onerror = (e) => {
            console.error('Video error:', e);
            video.classList.add('error');
            video.classList.remove('testing');
            showToast('Video error: ' + e.message, 'error');
            resolve();
          };
        });
        
      } catch (error) {
        console.error('Video test failed:', error);
        video.classList.add('error');
        video.classList.remove('testing');
        showToast('Video test failed: ' + error.message, 'error');
      }
    }

    async function testBarcode() {
      try {
        showToast('Testing barcode detection...', 'warning');
        
        // Simulate a barcode detection to test the pipeline
        const testBarcode = '1234567890123';
        console.log('Testing barcode detection with:', testBarcode);
        
        // Simulate the detection callback
        if (typeof postScan === 'function') {
          await postScan(testBarcode);
          showToast('Barcode detection test successful!', 'success');
        } else {
          showToast('postScan function not available', 'error');
        }
      } catch (e) {
        console.error('Barcode test failed:', e);
        showToast('Barcode test failed: ' + e.message, 'error');
      }
    }

    async function requestCameraPermission() {
      if (!isCameraSupported) {
        showToast('Camera not supported in this browser. Use manual entry.', 'error');
        return;
      }

      console.log('Requesting camera permission...');
      console.log('Available APIs:', {
        mediaDevices: !!navigator.mediaDevices,
        getUserMedia: !!navigator.getUserMedia,
        webkitGetUserMedia: !!navigator.webkitGetUserMedia,
        mozGetUserMedia: !!navigator.mozGetUserMedia,
        msGetUserMedia: !!navigator.msGetUserMedia
      });

      try {
        showToast('Requesting camera permission...', 'warning');
        
        const stream = await getUserMediaPolyfill({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        video.srcObject = stream;
        currentStream = stream;
        showToast('Camera permission granted!', 'success');
        
        // Stop the stream after permission is granted
        setTimeout(() => {
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
            video.srcObject = null;
          }
        }, 2000);
        
      } catch (error) {
        console.error('Camera permission error:', error);
        if (error.name === 'NotAllowedError') {
          showToast('Camera access denied. Please enable in Settings → Privacy → Camera → Safari', 'error');
        } else if (error.name === 'NotFoundError') {
          showToast('No camera found on this device', 'error');
        } else {
          showToast(`Camera error: ${error.message}`, 'error');
        }
      }
    }

    async function startScanning() {
      if (isScanning) {
        showToast('Scanner already running!', 'warning');
        return;
      }
      
      if (!isCameraSupported) {
        showToast('Camera not supported in this browser. Use manual entry.', 'error');
        return;
      }
      
      // Check if QuaggaJS library is loaded
      if (typeof Quagga === 'undefined') {
        showToast('Barcode library not loaded. Please refresh the page.', 'error');
        console.error('QuaggaJS library not available');
        return;
      }

      try {
        console.log('Starting QuaggaJS scanner...');
        showToast('Starting scanner...', 'warning');
        
        // Initialize frame stats
        frameStats.startTime = Date.now();
        frameStats.totalFrames = 0;
        frameStats.successfulScans = 0;
        frameStats.failedScans = 0;
        frameStats.frameQuality = [];
        
        // Configure QuaggaJS
        Quagga.init({
          inputStream: {
            name: "Live",
            type: "LiveStream",
            target: video,
            constraints: {
              width: { min: 640, ideal: 1280, max: 1920 },
              height: { min: 480, ideal: 720, max: 1080 },
              facingMode: "environment", // Use back camera on mobile
              aspectRatio: { min: 1, max: 2 }
            },
            area: { // Only read barcodes in center 80% of the video
              top: "10%",
              right: "10%",
              left: "10%",
              bottom: "10%"
            }
          },
          decoder: {
            readers: [
              "code_128_reader",
              "ean_reader",
              "ean_8_reader",
              "code_39_reader",
              "code_39_vin_reader",
              "codabar_reader",
              "upc_reader",
              "upc_e_reader",
              "i2of5_reader"
            ],
            multiple: false, // Only return one result at a time
            debug: {
              showCanvas: false,
              showPatches: false,
              showFoundPatches: false,
              showSkeleton: false,
              showLabels: false,
              showPatchLabels: false,
              showRemainingPatchLabels: false,
              boxFromPatches: {
                showTransformed: false,
                showTransformedBox: false,
                showBB: false
              }
            }
          },
          locate: true,
          frequency: 10 // Scan every 10 frames
        }, function(err) {
          if (err) {
            console.error('QuaggaJS initialization failed:', err);
            showToast('Scanner initialization failed: ' + err.message, 'error');
            return;
          }
          
          console.log('QuaggaJS initialized successfully');
          showToast('Scanner started successfully!', 'success');
          isScanning = true;
          
          // Start scanning
          Quagga.start();
          
          // Add visual feedback
          video.classList.add('testing');
          video.classList.remove('error');
        });
        
        // Handle successful scans
        Quagga.onDetected(function(result) {
          const code = result.codeResult.code;
          console.log('Barcode detected:', code);
          
          const now = Date.now();
          // Deduplicate rapid repeats
          if (code && (code !== lastText || now - lastAt > 1500)) {
            lastText = code;
            lastAt = now;
            frameStats.lastScanTime = now;
            frameStats.successfulScans++;
            
            postScan(code);
            showToast(`Barcode detected: ${code}`, 'success');
            
            // Add visual feedback
            video.style.border = '3px solid #4CAF50';
            setTimeout(() => {
              video.style.border = '';
            }, 2000);
          }
        });
        
        // Handle processing events for frame statistics
        Quagga.onProcessed(function(result) {
          frameStats.totalFrames++;
          if (!result) {
            frameStats.failedScans++;
          }
        });
        
        showToast('Scanner started successfully!', 'success');
        console.log('Scanning started successfully');
        updateDebugInfo();
        
      } catch (e) {
        console.error('Scanning start failed:', e);
        showToast('Failed to start scanning: ' + e.message, 'error');
      }
    }

    async function stopScanning() {
      if (isScanning) {
        try {
          // Stop QuaggaJS
          Quagga.stop();
          isScanning = false;
          
          // Remove visual feedback
          video.classList.remove('testing', 'error');
          
          // Log final frame statistics
          if (frameStats.startTime) {
            const runtime = Math.round((Date.now() - frameStats.startTime) / 1000);
            const successRate = frameStats.totalFrames > 0 ? Math.round((frameStats.successfulScans / frameStats.totalFrames) * 100) : 0;
            console.log(`Scanner stopped. Final stats: ${frameStats.totalFrames} frames, ${frameStats.successfulScans} successful, ${frameStats.failedScans} failed, ${successRate}% success rate, ${runtime}s runtime`);
          }
          
          showToast('Scanner stopped');
          console.log('Scanner stopped');
          updateDebugInfo();
        } catch (e) {
          console.error('Error stopping scanner:', e);
        }
      }
    }
    
    async function stopVideo() {
      if (currentStream) {
        try {
          currentStream.getTracks().forEach(track => track.stop());
          currentStream = null;
          video.srcObject = null;
          video.style.display = 'none';
          video.classList.remove('testing', 'error');
          showToast('Video stopped');
          console.log('Video stopped');
          updateDebugInfo();
        } catch (e) {
          console.error('Error stopping video:', e);
        }
      }
    }

    async function restartVideo() {
      console.log('Restarting video stream...');
      showToast('Restarting video stream...', 'warning');
      await stopScanning(); // Stop scanning first
      await stopVideo(); // Stop the current stream
      await requestCameraPermission(); // Request permission again
      await startScanning(); // Start scanning with the new stream
      showToast('Video stream restarted successfully!', 'success');
      console.log('Video stream restarted successfully');
      updateDebugInfo();
    }
    
    async function recoverVideoStream() {
      console.log('Attempting to recover video stream...');
      if (currentStream && currentStream.active) {
        try {
          // Reconnect the video element to the existing stream
          video.srcObject = currentStream;
          await new Promise(resolve => {
            video.onloadedmetadata = resolve;
            video.onerror = () => resolve();
            // Timeout after 3 seconds
            setTimeout(resolve, 3000);
          });
          
          if (video.readyState >= 2) {
            console.log('Video stream recovered successfully');
            showToast('Video stream recovered!', 'success');
            return true;
          }
        } catch (e) {
          console.log('Video recovery failed:', e);
        }
      }
      
      // If recovery failed, do full restart
      console.log('Recovery failed, doing full restart...');
      await restartVideo();
      return false;
    }

    async function captureAndDecode() {
      try {
        if (!video.srcObject) {
          showToast('No video stream available', 'error');
          return;
        }
        
        showToast('Capturing frame...', 'warning');
        console.log('Capturing frame for manual decode...');
        
        // Check if video stream is still active
        if (video.readyState === 0) {
          showToast('Video stream not ready, restarting...', 'warning');
          await restartVideo();
          return;
        }
        
        // Create a canvas to capture the current video frame
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Draw the current video frame to canvas
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        console.log('Frame captured, dimensions:', canvas.width, 'x', canvas.height);
        
        // Use QuaggaJS to decode the captured frame
        try {
          const result = await new Promise((resolve, reject) => {
            Quagga.decodeSingle({
              src: canvas.toDataURL(),
              numOfWorkers: 0,
              inputStream: {
                size: 800
              },
              decoder: {
                readers: [
                  "code_128_reader",
                  "ean_reader",
                  "ean_8_reader",
                  "code_39_reader",
                  "code_39_vin_reader",
                  "codabar_reader",
                  "upc_reader",
                  "upc_e_reader",
                  "i2of5_reader"
                ]
              },
              locate: true
            }, function(result) {
              if (result && result.codeResult) {
                resolve(result);
              } else {
                reject(new Error('No barcode found'));
              }
            });
          });
          
          const code = result.codeResult.code;
          console.log('Manual decode successful:', code);
          showToast(`Barcode detected: ${code}`, 'success');
          postScan(code);
          
        } catch (e) {
          console.log('Manual decode failed:', e);
          showToast('No barcode found in captured frame', 'warning');
        }
        
        // Check if video stream is still working after capture
        setTimeout(async () => {
          if (!video.srcObject || video.readyState === 0) {
            console.log('Video stream interrupted after capture, attempting recovery...');
            await recoverVideoStream();
          }
        }, 2000);
        
      } catch (e) {
        console.error('Capture failed:', e);
        showToast('Capture failed: ' + e.message, 'error');
        
        // Only restart if absolutely necessary
        if (!video.srcObject && !currentStream) {
          console.log('Complete stream loss, attempting recovery...');
          await recoverVideoStream();
        }
      }
    }

    startBtn.addEventListener('click', startScanning);
    stopBtn.addEventListener('click', stopScanning);
    stopVideoBtn.addEventListener('click', stopVideo);
    restartVideoBtn.addEventListener('click', restartVideo);
    recoverVideoBtn.addEventListener('click', recoverVideoStream);
    permissionBtn.addEventListener('click', requestCameraPermission);
    testVideoBtn.addEventListener('click', testVideo);
    testBarcodeBtn.addEventListener('click', testBarcode);
    generateTestBarcodeBtn.addEventListener('click', generateTestBarcode);
    captureBtn.addEventListener('click', captureAndDecode);
    exportFramesBtn.addEventListener('click', exportFailedFrames);
    exportStatsBtn.addEventListener('click', exportFrameStats);
    debugToggleBtn.addEventListener('click', toggleDebug);
    
    manualBtn.addEventListener('click', () => {
      const val = (manualInput.value || '').trim();
      if (!val) return showToast('Enter a barcode', 'error');
      postScan(val);
      manualInput.value = '';
    });

    newItemForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const itemNameInput = document.getElementById('itemName');
      const itemName = itemNameInput.value.trim();
      const itemGame = document.getElementById('itemGame').value || null;
      const itemSet = document.getElementById('itemSet').value || null;
      const itemNumber = document.getElementById('itemNumber').value || null;
      const itemQuantity = parseInt(document.getElementById('itemQuantity').value) || 1;
      const itemPrice = parseFloat(document.getElementById('itemPrice').value) || null;
      const itemLocation = document.getElementById('itemLocation').value || null;
      const itemDescription = document.getElementById('itemDescription').value || null;
      const itemNotes = document.getElementById('itemNotes').value || null;

      if (!itemName) {
        showToast('Item name cannot be empty.', 'error');
        return;
      }

      if (!pendingBarcode) {
        showToast('No barcode found. Please scan again.', 'error');
        return;
      }

      const formData = {
        barcode: pendingBarcode,
        name: itemName,
        game: itemGame,
        set_name: itemSet,
        number_in_set: itemNumber,
        quantity: itemQuantity,
        location: itemLocation,
        notes: itemNotes,
        price: itemPrice,
        description: itemDescription,
      };
      
      await createNewItem(formData);
    });

    // Close modal when clicking outside
    newItemModal.addEventListener('click', (e) => {
      if (e.target === newItemModal) {
        closeNewItemModal();
      }
    });
  </script>
</body>
</html>